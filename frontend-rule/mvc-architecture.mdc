---
description: MVC 架构模式使用指南 - ViewController 和 Manager 使用标准
---

# MVC 架构模式：ViewController 和 Manager

## 基本概念

项目采用 MVC（Model-View-Controller）架构模式，将视图与逻辑分离，以面向对象的方式组织前端逻辑。该模式的优点包括：

- **可维护性**：复杂逻辑集中在逻辑层，视图层保持干净
- **可复用性**：Managers 可以在多个 ViewControllers 中复用
- **可测试性**：逻辑层可以独立测试
- **性能优化**：使用发布订阅模式避免不必要的重新渲染

## 架构层次

### Service（服务层）

- **职责**：提供全局通用功能和服务
- **特点**：全局单例，生命周期与应用一致
- **示例**：用户服务、订阅服务、资源服务

### Manager（管理层）

- **职责**：封装可复用的独立逻辑块，请保持职责单一
- **特点**：可以被多个 ViewControllers 复用
- **示例**：数据管理、状态管理、业务逻辑处理

### ViewController（视图控制器层）

- **职责**：处理视图交互，连接视图和逻辑
- **特点**：绑定到特定视图，处理用户交互
- **示例**：页面交互处理、表单处理、列表操作

### View（视图层）

- **职责**：纯 UI 展示和用户交互
- **特点**：无业务逻辑，只负责展示和事件传递

## 依赖关系规则

```
ViewController → Manager → Service
     ↓            ↓
   View        Manager
```

**规则：**

- ViewController 可以依赖 Manager、Service
- Manager 可以依赖 Service 或其他 Managers，但**不能**依赖 ViewController
- Service 可以依赖 Manager，但**不能**依赖 ViewController
- View 只依赖 ViewController，不直接依赖 Manager 或 Service

## ViewController 实现标准

### 基本结构

```typescript
// 定义初始状态
const initialState = {
  isLoading: false,
  data: null,
  error: null,
};

class MyViewController {
  private readonly store = createStore(
    immer(combine(initialState, () => ({}))),
  );

  // 组合其他 Managers
  private readonly dataManager = new DataManager();
  private readonly disposerManager = new DisposerManager();

  // 通过构造函数传入依赖（依赖注入）
  constructor(
    private readonly userService: IUserService,
    private readonly dataManager: DataManager,
  ) {}

  // 获取状态
  get state() {
    return this.store.getState();
  }

  // 更新状态
  setState(updater: (state: typeof initialState) => void) {
    this.store.setState(updater);
  }

  // 启动生命周期
  async bootstrap(options: BootstrapOptions) {
    // 初始化数据
    // 设置事件监听器
    // 订阅 Store 变化
    this.disposerManager.addDisposeFn(
      this.dataManager.store.subscribe(() => {
        this.handleDataChange();
      }),
    );
  }

  // 清理生命周期
  dispose() {
    // 清理所有订阅和资源
    this.disposerManager.dispose();
    this.dataManager.dispose();
  }

  // 处理用户交互
  handleUserAction() {
    // 处理逻辑
  }
}
```

### 在 React 组件中使用

```typescript
function MyComponent(props: MyComponentProps) {
  const userService = useServices(IUserService);
  const dataManager = useState(() => new DataManager());

  // 创建 ViewController 实例
  const [vc] = useState(() =>
    new MyViewController(userService, dataManager)
  );

  // 启动和清理
  useEffect(() => {
    vc.bootstrap({ /* options */ });

    return () => {
      vc.dispose();
    };
    // 不需要依赖
  }, []);

  // 使用 ViewController 状态和方法
  const state = vc.state;

  return (
    <div>
      {state.isLoading && <Loading />}
      <Button onClick={() => vc.handleUserAction()}>
        Action
      </Button>
    </div>
  );
}
```

### 使用 CombinedStore
* 复杂状态管理请使用combinedStore
* 在视图中，由于要在状态变化的时候去触发视图更新，在使用通过构造函数传入依赖的写法中，需要做state的计算属性的时候，在视图中使用 useCombinedStore，可以很好的保证视图更新的情况下让逻辑简单
* useCombinedStore 的 第二个参数要传入一个无参数的选择器，直接取数据



```typescript
class ComplexViewController {
  private readonly filterStore = createStore(/* ... */);
  private readonly dataStore = createStore(/* ... */);

  readonly combinedStore: CombinedStore<ReadonlyStoreApi<unknown>[]>;

  constructor() {
    // 首先初始化所有 Stores
    this.filterStore = createStore(/* ... */);
    this.dataStore = createStore(/* ... */);

    // 最后初始化 combinedStore，确保所有 Stores 都已初始化
    this.combinedStore = createCombinedStore([
      this.filterStore,
      this.dataStore,
    ] as const);
  }

  get dataStoreState(){
    return this.dataStore.getState()
  }

  // 计算属性：直接从原始 stores 获取数据，而不是从 combinedStore
  get filteredData() {
    const filter = this.filterStore.getState();
    const data = this.dataStore.getState();
    return data.items.filter((item) => item.category === filter.category);
  }
}
```
视图中使用

```jsx

function Component(...){
  // 直接取状态
  const xx = useCombinedStore(vc.combinedStore, ()=> vc.dataStoreState.xxx)
  // 取计算值
  const yy = useCombinedStore(vc.combinedStore, ()=>vc.filteredData())
}

```

## Manager 实现标准

### 基本结构

```typescript
class MyManager {
  private readonly store = createStore(
    immer(combine(initialState, () => ({}))),
  );

  private readonly disposerManager = new DisposerManager();

  constructor(private readonly userService: IUserService) {}

  get state() {
    return this.store.getState();
  }

  setState(updater: typeof initialState){
    this.setState(updater)
  }

  async bootstrap() {
    // 初始化逻辑
  }

  dispose() {
    this.disposerManager.dispose();
  }

  // 业务方法
  async performAction() {
    // 实现逻辑
  }
}
```

## 使用场景

### 场景 1：简单交互处理

```typescript
// 如果交互逻辑简单，可以直接在组件中处理
function SimpleComponent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return <Button onClick={handleClick}>Count: {count}</Button>;
}
```

### 场景 2：复杂交互处理

```typescript
// 如果交互逻辑复杂，应该使用 ViewController
class ComplexViewController {
  private readonly store = createStore(...);
  private readonly apiManager = new ApiManager();

  async handleSubmit(formData: FormData) {
    // 验证数据
    // 调用 API
    // 处理错误
    // 更新状态
    // 触发副作用
  }
}

function ComplexForm() {
  const [vc] = useState(() => new ComplexViewController());

  useEffect(() => {
    vc.bootstrap();
    return () => vc.dispose();
  }, []);

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      vc.handleSubmit(new FormData(e.currentTarget));
    }}>
      {/* 表单字段 */}
    </form>
  );
}
```

### 场景 3：Bootstrap 模式

```typescript
// 使用 Bootstrap 组件管理 ViewController 生命周期
function MyBootstrap({ children }: { children: ReactNode }) {
  const userService = useServices(IUserService);
  const dataService = useServices(IDataService);

  const [vc] = useState(() =>
    new MyViewController(userService, dataService)
  );

  return (
    <ViewControllerContext.Provider value={vc}>
      {children}
    </ViewControllerContext.Provider>
  );
}

// 在页面中使用
function MyPage() {
  return (
    <MyBootstrap>
      <MyPageContent />
    </MyBootstrap>
  );
}
```

## 约束

1. **简单逻辑直接在组件中处理**：不需要为所有交互都创建 ViewController
2. **复杂逻辑使用 ViewController**：当交互涉及多个步骤、状态管理、API 调用时使用 ViewController
3. **Managers 可复用**：多个 ViewControllers 可以共享同一个 Manager
4. **遵循依赖关系**：不要违反依赖关系规则，所有依赖都要通过构造函数传入，在 `new` 的时候传递实例（不需要自动注入或 Container 等复杂概念）
5. **及时清理资源**：在 `dispose` 方法中清理所有订阅和资源
6. **使用 DisposerManager**：统一管理所有需要清理的资源